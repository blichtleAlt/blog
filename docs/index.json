[{
    "title": "814. Binary Tree Pruning",
    "date": "",
    "description": "",
    "body": "We are given the head node root of a binary tree, where additionally every node\u0026rsquo;s value is either a 0 or a 1.\nReturn the same tree where every subtree (of the given tree) not containing a 1 has been removed.\n(Recall that the subtree of a node X is X, plus every node that is a descendant of X.)\nExample 1:\n1 \\ 0 / \\ 0 1 Return:\n1 \\ 0 \\ 1 Exmaple 2:\n1 / \\ 0 1 / \\ / \\ 0 0 0 1 Return:\n1 \\ 1 \\ 1 ",
    "ref": "/hugo/blog/binary-tree-pruning/"
  },{
    "title": "100. Same Tree",
    "date": "",
    "description": "Leetcode solution",
    "body": " ",
    "ref": "/hugo/blog/same-tree/"
  },{
    "title": "113. Path Sum II",
    "date": "",
    "description": "",
    "body": "Given a binary tree and a sum, find all root-to-leaf paths where each path\u0026rsquo;s sum equals the given sum.\nNote: A leaf is a node with no children.\nExample: Given the below binary tree and sum = 22,\n5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 Return:\n[ [5,4,11,2], [5,8,4,5] ] Idea: We can solve this using a recursive depth first search approach. The key idea is here, we want to keep a list of all the values that we have seen so far, and what the remaining sum is. So for any given node, if we find its a leaf and its value is equal to the remainingSum\nSolution: class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pathSum(TreeNode* root, int sum) { vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; paths; vector\u0026lt;int\u0026gt; path; findPaths(root, sum, path, paths); return paths; } private: void findPaths(TreeNode* node, int sum, vector\u0026lt;int\u0026gt;\u0026amp; path, vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt;\u0026amp; paths) { if (!node) return; path.push_back(node -\u0026gt; val); if (!(node -\u0026gt; left) \u0026amp;\u0026amp; !(node -\u0026gt; right) \u0026amp;\u0026amp; sum == node -\u0026gt; val) paths.push_back(path); findPaths(node -\u0026gt; left, sum - node -\u0026gt; val, path, paths); findPaths(node -\u0026gt; right, sum - node -\u0026gt; val, path, paths); path.pop_back(); } }; Complexity Analysis: Time Complexity: O(N^2)O(N 2 ) where NN are the number of nodes in a tree. In the worst case, we could have a complete binary tree and if that is the case, then there would be N/2N/2 leafs. For every leaf, we perform a potential O(N)O(N) operation of copying over the pathNodes nodes to a new list to be added to the final pathsList. Hence, the complexity in the worst case could be O(N^2)O(N 2 ).\nSpace Complexity: O(N)O(N). The space complexity, like many other problems is debatable here. I personally choose not to consider the space occupied by the output in the space complexity. So, all the new lists that we create for the paths are actually a part of the output and hence, don\u0026rsquo;t count towards the final space complexity. The only additional space that we use is the pathNodes list to keep track of nodes along a branch.\nWe could include the space occupied by the new lists (and hence the output) in the space complexity and in that case the space would be O(N^2)O(N 2 ). There\u0026rsquo;s a great answer on Stack Overflow about whether to consider input and output space in the space complexity or not. I prefer not to include them.\n",
    "ref": "/hugo/blog/path-sum-ii/"
  },{
    "title": "About",
    "date": "",
    "description": "",
    "body": "Todo\n",
    "ref": "/hugo/about/"
  },{
    "title": "Emoji Support",
    "date": "",
    "description": "Guide to emoji usage in Hugo",
    "body": "Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your siteâ€™s configuration and then you can type emoji shorthand codes directly in content files; e.g.\nðŸ™ˆ :see_no_evil: ðŸ™‰ :hear_no_evil: ðŸ™Š :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\n N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }",
    "ref": "/hugo/blog/emoji-support/"
  },{
    "title": "Contact",
    "date": "",
    "description": "",
    "body": "",
    "ref": "/hugo/contact/"
  }]
